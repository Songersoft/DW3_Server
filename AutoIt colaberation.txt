Server Socket Array:
aSocket_recv[0 .. gSocket_max][eSocket .. eSocket_chat_sequence] on connected socket index
aSocket_send[^][^] on connected socket index

I am writing my first game server. It does a lot of things just like the Diablo 2 server did. I started to use that to model what this server needed to do.  Things it probably needs: a propper ack bit field in packet, measuring round trip time to avoid congestion.  It is functional now: detecting connection on client and server, downloading all connected players when player joins, chat, and player positions are relayed.  Drawing net players would be easy at this point, but I hesitate for two reasons one: I should manage the code for better ledgablity and understanding.  Second: last time I tried to add NPC I 
couldn't get the placement math right.  Not b/c it's not easily doable but b/c I suck at math sometimes.  So I am bringing this project here.

Now my game is fairly simple, maybe I've never 'finished' this sort of thing before, but I have done it many times.  It's just a tile placement loop: aWorld[layer][x][y]= iTile_pic_index.  Actually aWorld[world][l][x][y] but that's just so I can revert last worlds very quickly.

I am reasonably flutant with SDL, C++, and AutoIt and have transfered SDL projects between AutoIt and C++.  It's not difficult.  There are many things I am doing to improve speed and some hypothetical goals may not be realistically attainable in AutoIt.  If that day comes this project can start moving to C++.  Though if I continue remaking Dragon Warrior 3 I will certainly improve upon the original within AutoIt.  For example I will have tile layers, even if only 2 in AutoIt.

Honestly it's almost easier for me to go from AutoIt SDL design to C++.  There is less I worry about in AutoIt and it forces me to work on things like performance issues for example, if I can get it to run in AutoIt then I can get it to run 10x the magnitude in C++.  Then when converting over to C++ I already have a specific code outline to be met.

Plus I get to share it with you here.


Some concepts:
I use a board surface to quickly display the environment around the player.
Board is created at some size and world surrounding player is drawn to it.
The bigger the board surface the less likely a board redraw event will need to occure, but more memory the client consumes.

Board must be redrawn when the player reaches the bounds of the board (board of course gets it's data from tile[ world[w][l][x][y] ].
Board has layers just like world so that I may seporate drawing and draw between them. aBoard[layer_max]
 
A rectange surrounding player of screen size is copied from aBoard to screen.

[picture]

This is just the basic outline, aBoard and aWorld are probably dllstructs.

Areas are to subdivide words.  They will be extreamly useful for managing world: people[npc], items, hotspot, ect.  Areas have a position: x, y, w, h an out-of-bounds tile to draw outside of the bounds of the area position.  A world and position to load if you step out of the area position bounds.  But srsly if you care you can just look at the code.

The world data

World[x][y] = 

Pair the world with tile, kinda like this: tile[ world[x][y].iTile ]

World Data starts with a header: width, height, tile_max
Tile_max is to create and then read back the cell padding of this human friendly world data file: 

Ultimatly I want to 
and tile[] is a list of tile surfaces.
I'm so far ahead of myself I really just want to provide the source and start asking some of my questions to mold this project into a client-server game.